/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "system_stm32f4xx.h"
#include "timer.h"
//#include "eventman.h"
#include "led.h"
#include "melody.h"
#include "lightsensor.h"
#include "temhumsensor.h"
#include "eventbutton.h"
#include "button.h"
#include "Ucglib.h"
#include "uartcmd.h"
#include "serial.h"
#include <stdint.h>
#include <stdio.h>
#include <string.h>
//#include "temhumsensor.h"
//#include "Ucglib.h"
#include "stm32f401re.h"
#include "stm32f401re_rcc.h"
#include "stm32f401re_gpio.h"
#include "stm32f401re_spi.h"
#include "stm32f401re_i2c.h"

#define SPI1_CS_PORT			GPIOB
#define SPI1_CS_PIN				GPIO_Pin_6
#define SPI1_RST_PORT			GPIOC
#define SPI1_RST_PIN			GPIO_Pin_7
#define SPI1_MOSI_PORT			GPIOA
#define SPI1_MOSI_PIN			GPIO_Pin_7
#define SPI1_SCK_PORT			GPIOA
#define SPI1_SCK_PIN			GPIO_Pin_5
#define SPI1_RS_PORT			GPIOA
#define SPI1_RS_PIN			GPIO_Pin_9
#define SPI1_ENABLE_PORT		GPIOB
#define SPI1_ENABLE_PIN		GPIO_Pin_10
#define SPI1_MODE_PORT		GPIOA
#define SPI1_MODE_PIN			GPIO_Pin_8
typedef struct{
	uint8_t cmdid;
	uint8_t type;
}frm_common_t;
typedef struct {
	uint8_t cmdid;
	uint8_t type;
	uint8_t infor;
}frm_device_infor_t;
typedef struct{
	uint8_t cmdid;
	uint8_t type;
	uint8_t state;
}frm_buzzer_state_t;
typedef struct{
	uint8_t cmdid;
	uint8_t type;
	uint16_t value;
}frm_light_sensor_t;
typedef struct {
	uint8_t cmdid;
	uint8_t type;
	uint16_t value;

}frm_temperature_sensor_t;
typedef struct {
	uint8_t cmdid;
	uint8_t type;
	uint16_t value;
}frm_humidity_sensor_t;
typedef struct{
	uint8_t cmdid;
	uint8_t type;
	uint8_t text[20];
}frm_lcd_display_t;
typedef struct {
	uint8_t cmdid;
	uint8_t type;
	uint8_t numID;
	uint8_t color;
	uint8_t counter;
	uint8_t interval;
	uint8_t laststate;
	uint8_t reserved;
}frm_led_indicator_t;
typedef union{
	frm_common_t				frmCommon;
	frm_device_infor_t			frmDeviceInfor;
	frm_buzzer_state_t			frmBuzzerState;
	frm_led_indicator_t			frmLedIndicator;
	frm_light_sensor_t			frmLightSenSor;
	frm_temperature_sensor_t	frmTempSensor;
	frm_humidity_sensor_t		frmHumiSensor;
	frm_lcd_display_t			frmLcdDisplay;
}frm_receiver_t, *frm_receiver_p;
typedef enum{
	EVENT_EMPTY,
	EVENT_APP_INIT,
	EVENT_APP_FLUSHMEN_READY
}event_api_t, *event_api_p;
typedef enum{
	STATE_APP_STARTUP,
	STATE_APP_IDLE,
	STATE_APP_RESET
}state_app_t;
///////////////////////////////////
static ucg_t ucg;
static state_app_t eCurrentState;
//static uint8_t  led_id, led_color, led_num_blink, led_last_state, led_interval;
static uint8_t lux_red = 0, lux_blue = 0, lux_white = 0, lux_green = 0;
static uint8_t id_timer = NO_TIMER;
static uint32_t light, temperature, humidity;
///////////////////////////////////
/*
 * @func			Task_multiSensorScan
 * @brief			Read value tem,lux,hum and print on LCD
 * @param			None
 * @retval			None
 * */

static void
Task_mustiSensorScan(void)
{
	ucg_SetFont(&ucg, ucg_font_ncenR12_hr);
	static char src1[20] = "";
	static char src2[20] = "";
	static char src3[20] = "";
	temperature = (uint8_t)(TemHumSensor_GetTemp() / 100);
	humidity = (uint8_t)(TemHumSensor_GetHumi() / 100);
	light  = LightSensor_MeasureUseDMAMode();
	// Display output
	memset(src1, 0 , sizeof(src1));
	sprintf(src1, "Temp = %ld oC", temperature);
	ucg_DrawString(&ucg, 0, 32, 0, src1);

	memset(src2, 0, sizeof(src2));
	sprintf(src2, "Humi = %ld %%", humidity);
	ucg_DrawString(&ucg, 0, 52, 0, src2);

	memset(src3, 0 , sizeof(src3));
	sprintf(src3, "Light = %ld lux", light);
	ucg_DrawString(&ucg, 0, 72, 0, src3);
	LightSensor_SendPacketRespond(light);
	TempSensor_SendPacketRespond(temperature);
	HumiSensor_SendPacketRespond(humidity);
}
/*
 * @func			SetEventLed
 * @brief			Set event Led with Uart
 * @param			 uint8_t led_id, \
					 uint8_t led_color, \
					 uint8_t led_num_blink, \
					 uint8_t led_interval, \
					 uint8_t led_last_state
*/
void LedCmdSetState(
		 uint8_t led_id, \
		 uint8_t led_color, \
		 uint8_t led_num_blink, \
		 uint8_t led_interval, \
		 uint8_t led_last_state
)
{
	if(led_color == LED_COLOR_RED)
	{
		lux_red = 50 - lux_red;
		// set off all led
		lux_blue = lux_white = lux_green = 0;
		///////////////////////////////////////
		LedControl_SetAllColor(LED_COLOR_RED, lux_red);
		BuzzerControl_SendPacketRespond(1);
		BuzzerControl_SetMelody(pbeep);
		LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_RED, lux_red);
		LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_RED, lux_red);
	}
	else if(led_color == LED_COLOR_GREEN)
	{
		lux_green = 50 - lux_green;
		// set off all led
		lux_blue = lux_white = lux_red = 0;

		LedControl_SetAllColor(LED_COLOR_GREEN, lux_green);
		BuzzerControl_SendPacketRespond(1);
		BuzzerControl_SetMelody(pbeep);
		LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_GREEN, lux_green);
		LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_GREEN, lux_green);
	}
	else if(led_color == LED_COLOR_WHITE)
	{
		lux_white = 50 - lux_white;
		// set off all led
		lux_blue = lux_red = lux_green = 0;

		LedControl_SetAllColor(LED_COLOR_WHITE, lux_white);
		BuzzerControl_SendPacketRespond(1);
		BuzzerControl_SetMelody(pbeep);
		LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_WHITE, lux_white);
		LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_WHITE, lux_white);
	}
	else if(led_color == LED_COLOR_BLUE)
	{
		lux_blue = 50 -lux_blue;
		// set off all led
		lux_red = lux_white = lux_green = 0;

		LedControl_SetAllColor(LED_COLOR_BLUE, lux_blue);
		BuzzerControl_SendPacketRespond(1);
		BuzzerControl_SetMelody(pbeep);
		LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_BLUE, lux_blue);
		LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_BLUE, lux_blue);
	}
	else
		LedControl_BlinkStart(led_id, led_color, led_num_blink, led_interval, led_last_state);
}

/*
 * @func			SetEventBuzzer
 * @brief			Set event buzzer with Uart
 * @param			uint8_t buzzer_state
 * */
void BuzzerCmdSetState(
		uint8_t buzzer_state
){
	BuzzerControl_SetMelody(pbeep);
}
/*
 * @func			SetEventLcd
 * @brief			Set event lcd with Uart
 * @param			char*	text
 * */
void LcdCmdSetState(
		char *text
){
	// Stop MultiSensorScan
	if(id_timer != NO_TIMER)
	{
		TimerStop(id_timer);
		id_timer = NO_TIMER;
	}
	ucg_ClearScreen(&ucg);
	ucg_DrawString(&ucg, 20, 20, 0, text);
}
/*
 * @func			SetEventButton
 * @brief			Set event button
 * @param			uint8_t button_id
 * 					uint8_t button_state
 */
void ButtonCmdSetState(
		uint8_t button_id,
		uint8_t button_state
){
	if(button_id == BUTTON_KIT_ID1)
	{
		lux_red = 50 - lux_red;
		// set off all led
		lux_blue = lux_white = lux_green = 0;
		///////////////////////////////////////
		LedControl_SetAllColor(LED_COLOR_RED, lux_red);
		BuzzerControl_SendPacketRespond(1);
		BuzzerControl_SetMelody(pbeep);
		LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_RED, lux_red);
		LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_RED, lux_red);
	}
	else if(button_id == BUTTON_KIT_ID2)
	{
		lux_green = 50 - lux_green;
		// set off all led
		lux_blue = lux_white = lux_red = 0;

		LedControl_SetAllColor(LED_COLOR_GREEN, lux_green);
		BuzzerControl_SendPacketRespond(1);
		BuzzerControl_SetMelody(pbeep);
		LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_GREEN, lux_green);
		LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_GREEN, lux_green);
	}
	else if(button_id == BUTTON_KIT_ID4)
	{
		lux_white = 50 - lux_white;
		// set off all led
		lux_blue = lux_red = lux_green = 0;

		LedControl_SetAllColor(LED_COLOR_WHITE, lux_white);
		BuzzerControl_SendPacketRespond(1);
		BuzzerControl_SetMelody(pbeep);
		LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_WHITE, lux_white);
		LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_WHITE, lux_white);
	}
	else if(button_id == BUTTON_KIT_ID5)
	{
		lux_blue = 50 -lux_blue;
		// set off all led
		lux_red = lux_white = lux_green = 0;

		LedControl_SetAllColor(LED_COLOR_BLUE, lux_blue);
		BuzzerControl_SendPacketRespond(1);
		BuzzerControl_SetMelody(pbeep);
		LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_BLUE, lux_blue);
		LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_BLUE, lux_blue);
	}
	else // button_id == BUTTON_KIT_ID3;
	{
		ucg_ClearScreen(&ucg);
		Task_mustiSensorScan();
		if(id_timer == NO_TIMER)
		id_timer = TimerStart("EVENT_OF_BUTTON_3_PRESS_LOGIC", 6000, TIMER_REPEAT_FOREVER, Task_mustiSensorScan, NULL);
	}
}
/*
 * @func          GetStateApp
 * @brief         Get state of application
 * @param         None
 * @retval        State of application
 * */
static void
SetStateApp(
		state_app_t state
){
	eCurrentState  = state;
}
/*
 * @func          GetStateApp
 * @brief         Get state of application
 * @param         None
 * @retval        State of application
 * */
static state_app_t
GetStateApp(void)
{
	return eCurrentState;
}
/*
 * func            LoadConfiguration
 * brief           Print in LCD "IOT Pro...."
 * param           None
 * retval          None
 * */
static void
LoadConfiguration(void)
{
	ucg_ClearScreen(&ucg);
	ucg_DrawString(&ucg, 52, 32, 0,"IOT");
	ucg_DrawString(&ucg, 0, 53, 0,"Programming by");
	ucg_DrawString(&ucg, 52, 72, 0,"Lumi");
	ucg_DrawString(&ucg, 20, 92, 0,"SmartHome");
	char infor[] = "Device board: STM32F401RE Nucleo";
	Serial_SendPacket(CMD_OPT_NOT_USE, CMD_ID_LCD, CMD_TYPE_RES,(uint8_t*)infor,sizeof(infor));
}
/*
 * @func			DeviceStateMachine
 * @brief			State machine of the device
 * @param			event
 * @retval			None
 * */
void
DeviceStateMachine(
		uint8_t event
){
	switch(event){
		case EVENT_OF_BUTTON_3_PRESS_LOGIC:
		{
		ucg_ClearScreen(&ucg);
		Task_mustiSensorScan();
		if(id_timer == NO_TIMER)
		id_timer = TimerStart("EVENT_OF_BUTTON_3_PRESS_LOGIC", 6000, TIMER_REPEAT_FOREVER, Task_mustiSensorScan, NULL);
		break;
		}
		case EVENT_OF_BUTTON_1_PRESS_LOGIC:
		{
			lux_red = 50 - lux_red;
			// set off all led
			lux_blue = lux_white = lux_green = 0;
			///////////////////////////////////////
			LedControl_SetAllColor(LED_COLOR_RED, lux_red);
			BuzzerControl_SendPacketRespond(1);
			BuzzerControl_SetMelody(pbeep);
			LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_RED, lux_red);
			LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_RED, lux_red);
			break;
		}
		case EVENT_OF_BUTTON_2_PRESS_LOGIC:
		{
			lux_green = 50 - lux_green;
			// set off all led
			lux_blue = lux_white = lux_red = 0;

			LedControl_SetAllColor(LED_COLOR_GREEN, lux_green);
			BuzzerControl_SendPacketRespond(1);
			BuzzerControl_SetMelody(pbeep);
			LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_GREEN, lux_green);
			LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_GREEN, lux_green);
			break;
		}
		case EVENT_OF_BUTTON_4_PRESS_LOGIC:
		{
			lux_white = 50 - lux_white;
			// set off all led
			lux_blue = lux_red = lux_green = 0;

			LedControl_SetAllColor(LED_COLOR_WHITE, lux_white);
			BuzzerControl_SendPacketRespond(1);
			BuzzerControl_SetMelody(pbeep);
			LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_WHITE, lux_white);
			LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_WHITE, lux_white);
			break;
		}
		case EVENT_OF_BUTTON_5_PRESS_LOGIC:
		{
			lux_blue = 50 -lux_blue;
			// set off all led
			lux_red = lux_white = lux_green = 0;

			LedControl_SetAllColor(LED_COLOR_BLUE, lux_blue);
			BuzzerControl_SendPacketRespond(1);
			BuzzerControl_SetMelody(pbeep);
			LedControl_SendPacketRespond(LED_KIT_ID0, LED_COLOR_BLUE, lux_blue);
			LedControl_SendPacketRespond(LED_KIT_ID1, LED_COLOR_BLUE, lux_blue);
			break;
		}

		break;
		default:
			break;
	}
}
/*
 * @func          AppStateManage
 * @brief         Manage state application
 * @param         None
 * @retval        None
 * */
static void
AppStateManager(
		uint8_t event
){
	switch(GetStateApp())
	{
	case STATE_APP_STARTUP:
		if(event == EVENT_APP_INIT)
		{
			LoadConfiguration();
			SetStateApp(STATE_APP_IDLE);
		}
		break;
	case STATE_APP_IDLE:
		//delay_ms(500);
		DeviceStateMachine(event);
		break;
	case STATE_APP_RESET:
		break;
	default:
		break;
	}
}
/*
 * @func           AppInitCommon
 * @brief          Init
 * param           None
 * retval          None
 * */

void SPI1_Init(void){
	GPIO_InitTypeDef GPIO_InitStructure;
	SPI_InitTypeDef SPI_InitStructure;
	// Enable clock for GPIOA - GPIOB - GPIOC
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	// Config AF for pin SCK(PA5) and MOSI (PA7)w
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_InitStructure.GPIO_Pin = SPI1_SCK_PIN| SPI1_MOSI_PIN;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_PinAFConfig(SPI1_SCK_PORT, GPIO_PinSource5, GPIO_AF_SPI1);
	GPIO_PinAFConfig(SPI1_MOSI_PORT, GPIO_PinSource7, GPIO_AF_SPI1);

	/// Config pin CS(PB6) and RST(PC7) wwith mode output and pull down
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_Speed =  GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;

	GPIO_InitStructure.GPIO_Pin = SPI1_CS_PIN;
	GPIO_Init(SPI1_CS_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = SPI1_RST_PIN;
	GPIO_Init(SPI1_RST_PORT, &GPIO_InitStructure);
	/// Config pin RS(PA9) and MODE(PA8) wwith mode output/
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_InitStructure.GPIO_Pin = SPI1_RS_PIN | SPI1_MODE_PIN;
	GPIO_Init(SPI1_RS_PORT, &GPIO_InitStructure);
	// Config pin ENEBLA(PB10) wwith mode output
	GPIO_InitStructure.GPIO_Pin = SPI1_ENABLE_PIN;
	GPIO_Init(SPI1_ENABLE_PORT, &GPIO_InitStructure);

	// enable peripheral clock SPI1
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);

	// set to hafl deplex mode, seperate MOSI Lines
	SPI_InitStructure.SPI_Direction = SPI_Direction_1Line_Tx;

	// Use SPI1 as slave mode
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;

	// One packet of data is 8 bits wide
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;

	// Clock is low when idle
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;

	// Data sampled at first edge
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;

	//SPI frequency is APB2 frequency
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;

	// Set NSS us software
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;

	// data is trasmitted MSB first
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_LSB;

	SPI_Init(SPI1, &SPI_InitStructure);

	// Enable SPI1
	SPI_Cmd(SPI1, ENABLE);
}
void AppInitCommon()
{
	SystemCoreClockUpdate();
	TimerInit();
	EventSerial_Init();
//	EventSchedulerInit(AppStateManager);
//	EventSerial_SetEventLedCallback(LedCmdSetState);
//	EventSerial_SetEventBuzzerCallback(BuzzerCmdSetState);
//	EventSerial_SetEventButtonCallback(ButtonCmdSetState);
//	EventSerial_SetEventLcdCallback(LcdCmdSetState);
//	EventButton_Init();
//	BuzzerControl_Init();
//	LedControl_Init();
//	LightSensor_Init(ADC_READ_MODE_DMA);
//	TemHumSensor_Init();
	Ucglib4WireSWSPI_begin(&ucg,UCG_FONT_MODE_SOLID);
	ucg_ClearScreen(&ucg);
	ucg_SetFont(&ucg, ucg_font_ncenR12_hr);
	ucg_SetColor(&ucg, 0, 255, 255, 255);
	ucg_SetColor(&ucg, 1, 0, 0, 0);
	ucg_SetRotate180(&ucg);
}

int main(void)
{
	AppInitCommon();
	SPI1_Init();
//	SetStateApp(STATE_APP_STARTUP);
//	EventSchedulerAdd(EVENT_APP_INIT);
	LoadConfiguration();
	while(1)
	{
		processTimerScheduler();
//		processEventScheduler();
//		processSerialReceiver();
	}
 return 0;
}
